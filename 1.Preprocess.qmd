---
title: "preprocess"
author: "Izar de Villasante"
params:
  ss: "samplesheet_FULL"
  betas: "betas_FULL"
server: shiny

---

```{r}
#| context: data
#| include: false
library(targets)
p <- params
print(p$ss)
targets::tar_load(p$ss)
ss<-eval(rlang::sym(p$ss))
```




```{r}
# targets::tar_load(params2$ss)
# ss<-eval(rlang::sym(params2$ss))

```


## Illumina Infinium Methylation Arrays

This technical guide covers how to analyze Illumina methylation Beadchips arrays
commonly known as EPIC/450K methylation arrays.
[here some description about a methylation array and how it is prepeared...](https://emea.support.illumina.com/content/dam/illumina-support/documents/documentation/chemistry_documentation/infinium_assays/infinium_hd_methylation/infinium-hd-methylation-guide-15019519-01.pdf)

## Preprocessing

The first step once you have your data is to load it to R in an appropriate
format. The ´minfi´ packages provides read.metharray functions for this purpose.
Also the functions `read.metharray.sheet`, `read.metharray.exp` can be used.
Those are wrappers around `read.metharray` to make it easier for the user. [Check this guideline ](https://bioconductor.org/packages/devel/bioc/vignettes/minfi/inst/doc/minfi.html#3_Reading_data) or type `vignette("minfi)` on an R console for more info.
In this case a built in function `cnv.methyl::read.metharray.exp.par()` is used which is a wrapper for minfi formula with
parallelization to speed up this process a little bit.

In order to use any of this formulas we first need to generate the sample_sheet.

### Sample sheet

The sample sheet contains inforamtion about your samples and the experimental setup.
It is mandatory to respect the column names in order to make the pipline work.
 ##It must contain the following columns:
 - Sample_Name
 - Basename

 ##Other recommended columns with technical details. Can be used to track and detect batch effects:
 - Project
 - Pool_ID
 - Sample_Plate
 - Sample_Well
 - Sample_Group
 - Sentrix_ID
 - Sentrix_Position

 ##Pheno columns:
 - Gender (will be predicted)
 - Type
 - Condition
 - Any other information

In the following table, you can take a look at the sample sheet used for this project.





```{r}
#| context: server
library(targets)
# source("~/Projects/report_functions.R")
# ss<-data.table::as.data.table(tar_read(params2$ss))

```

```{r}
#| context: server-start

library(circlize)
library(RColorBrewer)
library(DT)
library(ggplot2)
library(shiny)
library(shinyWidgets)
library(ggplot2)
library(data.table)
library(writexl)


```


```{r dtable}
dtable<-function(data){
  DT::datatable(
        { data},
        filter = 'top',
        # selection = list(mode = 'multiple', selected = c(1:10), target = 'column', selectable = c(-2, -3)),
        fillContainer = F,
        # style =  "bootstrap",

        extensions = 'Buttons',

        options = list(
          paging = TRUE,
          searching = TRUE,
          fixedColumns = TRUE,
          autoWidth = FALSE,
          scrollX=TRUE,
          digits=4,
          ordering = TRUE,
          dom = 'Bfrtip',
          buttons = list(
            list(
              extend = "collection",
              text = 'download entire dataset',
              action = DT::JS("function ( e, dt, node, config ) {
                                                    Shiny.setInputValue('test', true, {priority: 'event'});
                                                    }")
            ),
            'copy',
            'csv',
            'excel'
          ),

          class = "display",
          server=TRUE
        ),
      ) |> DT::formatRound(which(sapply(data,is.double)),4)
}
```

```{r}
#| context: server
myModal <- function() {

  div(id = "test",
      shiny::modalDialog(downloadButton("download1","Download data as csv"),
                         br(),
                         br(),
                         downloadButton("download2","Download data as excel"),
                         easyClose = TRUE, title = "Download Table")
  )
}

renderDT<- function(data){
  output$dtable <- DT::renderDataTable({
    dtable(data)
  })

    shiny::observeEvent(input$test, {
      print("hello")
      showModal(myModal())
    })
    output$download1 <- shiny::downloadHandler(
      filename = function() {
        paste("data-", Sys.Date(), ".csv", sep="")
      },
      content = function(file) {
        write.csv(data, file)
      }
    )

    output$download2 <- shiny::downloadHandler(
      filename = function() {
        paste("data-", Sys.Date(), ".xlsx", sep="")
      },
      content = function(file) {
        writexl::write_xlsx(data, file)
      })
}

```

```{r}

dtable(data.table::as.data.table(ss))
```

## Methylation data: The 2-channel methylation intensity file format .idat 

```{r}

tar_load(p$betas)
betas<-eval(rlang::sym(params$betas))
colnames(betas) <- ss[colnames(betas),Sample_Name,on="barcode"]
```


## DMPs Annotation data:

A dataframe with differentially methylated probes and annotation.

```{r}
library(data.table)

DMPann<-readRDS("data/dmps_FULL.rds")

#Transform to data.table format to visualize and perform data manipulations
DMPann<-data.table::setDT(DMPann)
setkey(DMPann,"rn")
```


```{r}
dtable(DMPann)
```


### 1.3.2.2. Heatmap

When working with methylation data we would usually want to have a representative heatmap of the methylation values across the samples and see which probes are differentially methylated for each contrast.
There are many different ways to achive that, I recommend taking a look at [the wonderful docs of complexHeatmap package](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html) for more options.

In this demonstration I will show a rather complete heatmap so you can see different useful options:

First of all let's define some functions for the color scales our heatmap will use:

```{r}
library(ComplexHeatmap)
library(circlize)
# Simple continuous palette: 
col_fun = colorRamp2(c(-1,-0.1, 0.1, 1), c("blue","white","white","red"))

# Continuous, uses a predefined color palette or manual color vector
col_fn<- function(x,n=100,palette=viridis::cividis(n)){
  colorRamp2( seq(min(x),max(x),length.out=n), palette)
}

# Continuous, monochrome breakpoints based on values distribution (quartiles):
col_fq <- function(x,probs=c(0,0.25,0.5,0.75,1),color ){
  colorRamp2( quantile(x,probs=probs), 
              monochromeR::generate_palette("white",
                blend_colour = color,  n_colours = length(probs)
                )
  )
}

# Continuous, monochrome can manually set breakpoints:
col_fbp <- function(x,bp,color){
  colorRamp2( bp, 
              monochromeR::generate_palette("white",
                blend_colour = color,  n_colours = length(bp)
                )
              )
}

```




The most relevant step is to choose an appropriate subset of representative probes/sites to show on our heatmap. 

Since we are interested on DMPs we select the probes based on the following:
For each contrast:
- DMPs must have adjusted p.value < 0.01
- DMPs must have a methylation differenece greater then 0.25
- Of those, only the top 5000 most variable probes across subjects are selected.

Feel free to modify this parameters at will.

```{r}
DMPann[rownames(betas),]
cg<-unique(unlist(
  sapply(unique(DMPann$Contrast),function(x){
  cg<-rownames(DMPann[DMPann$adj.P.Val<0.01 & abs(DMPann$diff_meanMeth)>0.25 & DMPann$Contrast==x,])
  betas_c <- betas[intersect(cg,rownames(betas)),]
  topcg<-rownames(top_beta(betas_c,5000))
  return(topcg)
  })
))
betas_heat<-betas[intersect(cg,rownames(betas)),]

```


Now we are ready to start constructing the heatmap. In fact, I will show how to create a composed heatmap from a list of heatmaps. 
The sintax for adding heatmaps is by adding heatmap objects, similar to `ggplot2`.

We will create a list of heatmaps to concatenate them vertically.
1. the main heatmap will contain the beta values and the following annotation about the different samples:
- categorical: Condition,Type.
- continuos: purity (some value I calculated about tumor purity prediction)
- annotation block: Type could be created in a similar way as Condition, but if you want to add the labels inside the box you must use anno_block. 


```{r}
ha_column = HeatmapAnnotation(
    annotation_name_side = "left", 
    
    Type = anno_block(gp=gpar(fill= c("purple","cyan")),
                      labels = levels(samplesheet$Type),
                      labels_gp = gpar(col = "white", fontsize = 10)),
    # Type = samplesheet$Type,                  
    Condition = samplesheet$Condition,
    purity = samplesheet$purity_FULL,

    col = #A list of named vectors were names = vector values and value = color.
      list(
      # Type = c("ARMS"="purple",NBL="cyan"),
      Condition = setNames(
        palette.colors(length(unique(samplesheet$Condition)),
                       palette = "Dark"
                       ),
        unique(samplesheet$Condition)
      ),
      purity = col_fbp(x=samplesheet$purity,bp=seq(min(samplesheet$purity_FULL),max(samplesheet$purity_FULL),length.out=5),color="green3")
      )

)
```

This heatmap is divided into 2 groups ARMS and NBL with the option `column_split`, in a similar way `column_km` can be used to split based on the clustering

2. Methylation difference for each contarast. They are one column each. It could be done as a single matrix just as the first heatmap. But I wanted to illustrate how to include heatmaps with a for loop. Pay attention to the trick to hide repeated legends.

3. Some random annotation, in this case Relation to cpg island (categorical).

Remember that the rows have to be the same for all the variables. This is already happening for the beta values, but may not be for the DMPs or annotation.

```{r, fig.dim=c(22,26)}
library(ComplexHeatmap)

heat_list<-Heatmap(
    matrix = betas_heat, 
          #Color:
          col=col_fn(betas_heat),#col_fun, # Color defined in col_fun above
          na_col="grey",
          
          #Label:
          heatmap_legend_param = list(
          at = c(0, 0.5, 1),
          # labels = c("hypo", 0, "hyper"),
          title = paste0(expression(beta),"-vals"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
          
          
          #Rows:
          show_row_names = F,
          #row_title = "Amino acids",
          row_names_side = "left",
          #left_annotation = ha_boxplot,
          # clustering_distance_rows = "manhattan",
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_title_side = "bottom",
          column_names_max_height = unit(4, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          cluster_columns=T,
          column_split = samplesheet$Type,
          column_title = paste0(expression(beta)," values"),

          #Annotation bar:
          top_annotation = ha_column,
         
            
          
          #Aspect ratios:
          #column_dend_height=unit(4, "cm")
           heatmap_width = unit(2, "npc"),
          heatmap_height = unit(16, "cm"),
              )
# Add methylation difference heatmap:  
for (contrast in unique(DMP_ann$Contrast))
{
  # There may be some missing probes for each contrast that are not DMPs so we assign a 0 val 
  cgs<-rownames(DMPann[DMPann$Contrast == contrast  ,])
  mat<-ifelse(
    rownames(betas_heat) %in% rownames(DMPann[DMPann$Contrast == contrast  ,]),
    DMPann[DMPann$Contrast == contrast  , "diff_meanMeth"],
    0)
 
  heat_list = heat_list + Heatmap(
    matrix = mat, 
    name = contrast,
          #Color:
          col=col_fun,#col_fun, # Color defined in col_fun above
          na_col="white",
          
          #Legend:
          heatmap_legend_param = list(
          at = c(-1, -0.1, 0.1, 1),
          # labels = c("hypo", "", "", "hyper"),
          title = paste0(expression(beta),"diff"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
    show_heatmap_legend = ifelse(contrast == unique(DMP_ann$Contrast)[1],T,F ),
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_names_max_height = unit(2, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          heatmap_width = unit(2, "npc"),
          
              )
  
}
# Add annotation
heat_list<-heat_list + 
  Heatmap(
    matrix = DMPann[rownames(betas_heat),"Relation_to_Island"], 
    name = "Relation to island",
    #Color:
    col=setNames(palette.colors(length(unique(DMPann$Relation_to_Island)),palette = "Set1"),sort(unique(DMPann$Relation_to_Island))),#col_fun, # Color defined in col_fun above
    #Legend:
    show_heatmap_legend = TRUE,
    show_column_names = TRUE,
    column_names_side = "top",
    column_names_max_height = unit(2, "cm"),
    column_names_gp = gpar(fontsize = 9),
    column_names_rot = 90,
    heatmap_width = unit(2, "npc"),
          
              )
draw(heat_list, row_title = "some row title", row_title_gp = gpar(col = "darkblue"),
    column_title = "some column title", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)
```

This is quite nice visually, but it would make more sense to check for the top 10000 sites instead or maybe focus on the DMPs of a particular contrast and see how it compares to the rest. 

Let's make those 2 changes to see how we would adapt the data.

### top 10000

We only need to change the betas_heat object since the values on DMPann are based on that.

```{r}
  betas_heat<-top_beta(betas,10000)

```

Now we copy everything else from the heatmap above and repeat

```{r, fig.dim=c(22,26)}
library(ComplexHeatmap)

heat_list<-Heatmap(
    matrix = betas_heat, 
          #Color:
          col=col_fn(betas_heat),#col_fun, # Color defined in col_fun above
          na_col="grey",
          
          #Label:
          heatmap_legend_param = list(
          at = c(0, 0.5, 1),
          # labels = c("hypo", 0, "hyper"),
          title = paste0(expression(beta),"-vals"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
          
          
          #Rows:
          show_row_names = F,
          #row_title = "Amino acids",
          row_names_side = "left",
          #left_annotation = ha_boxplot,
          # clustering_distance_rows = "manhattan",
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_title_side = "bottom",
          column_names_max_height = unit(4, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          cluster_columns=T,
          column_split = samplesheet$Type,
          column_title = paste0(expression(beta)," values"),

          #Annotation bar:
          top_annotation = ha_column,
         
            
          
          #Aspect ratios:
          #column_dend_height=unit(4, "cm")
           heatmap_width = unit(2, "npc"),
          heatmap_height = unit(16, "cm"),
              )
# Add methylation difference heatmap:  
for (contrast in unique(DMP_ann$Contrast))
{
  # There may be some missing probes for each contrast that are not DMPs so we assign a 0 val 
  cgs<-rownames(DMPann[DMPann$Contrast == contrast  ,])
  mat<-ifelse(
    rownames(betas_heat) %in% rownames(DMPann[DMPann$Contrast == contrast  ,]),
    DMPann[DMPann$Contrast == contrast  , "diff_meanMeth"],
    0)
 
  heat_list = heat_list + Heatmap(
    matrix = mat, 
    name = contrast,
          #Color:
          col=col_fun,#col_fun, # Color defined in col_fun above
          na_col="white",
          
          #Legend:
          heatmap_legend_param = list(
          at = c(-1, -0.1, 0.1, 1),
          # labels = c("hypo", "", "", "hyper"),
          title = paste0(expression(beta),"diff"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
    show_heatmap_legend = ifelse(contrast == unique(DMP_ann$Contrast)[1],T,F ),
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_names_max_height = unit(2, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          heatmap_width = unit(2, "npc"),
          
              )
  
}
# Add annotation
heat_list<-heat_list + 
  Heatmap(
    matrix = DMPann[rownames(betas_heat),"Relation_to_Island"], 
    name = "Relation to island",
    #Color:
    col=setNames(palette.colors(length(unique(DMPann$Relation_to_Island)),palette = "Set1"),sort(unique(DMPann$Relation_to_Island))),#col_fun, # Color defined in col_fun above
    #Legend:
    show_heatmap_legend = TRUE,
    show_column_names = TRUE,
    column_names_side = "top",
    column_names_max_height = unit(2, "cm"),
    column_names_gp = gpar(fontsize = 9),
    column_names_rot = 90,
    heatmap_width = unit(2, "npc"),
          
              )
draw(heat_list, row_title = "some row title", row_title_gp = gpar(col = "darkblue"),
    column_title = "some column title", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)
```

### At2-Nt2:metastasi

Let's take the metastasi contrast for instance. Let's take the top 10000 DMPs for that contrast:

```{r}
  cg<-rownames(DMPann[DMPann$adj.P.Val<0.01 & abs(DMPann$diff_meanMeth)>0.25 & DMPann$Contrast=="At2-Nt2:metastasi",])
  betas_c <- betas[intersect(cg,rownames(betas)),]
  betas_heat<-top_beta(betas_c,10000)
```

And copy the same code for the plot again:

```{r, fig.dim=c(22,26)}
library(ComplexHeatmap)

heat_list<-Heatmap(
    matrix = betas_heat, 
          #Color:
          col=col_fn(betas_heat),#col_fun, # Color defined in col_fun above
          na_col="grey",
          
          #Label:
          heatmap_legend_param = list(
          at = c(0, 0.5, 1),
          # labels = c("hypo", 0, "hyper"),
          title = paste0(expression(beta),"-vals"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
          
          
          #Rows:
          show_row_names = F,
          #row_title = "Amino acids",
          row_names_side = "left",
          #left_annotation = ha_boxplot,
          # clustering_distance_rows = "manhattan",
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_title_side = "bottom",
          column_names_max_height = unit(4, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          cluster_columns=T,
          column_split = samplesheet$Type,
          column_title = paste0(expression(beta)," values"),

          #Annotation bar:
          top_annotation = ha_column,
         
            
          
          #Aspect ratios:
          #column_dend_height=unit(4, "cm")
           heatmap_width = unit(2, "npc"),
          heatmap_height = unit(16, "cm"),
              )
# Add methylation difference heatmap:  
for (contrast in unique(DMP_ann$Contrast))
{
  # There may be some missing probes for each contrast that are not DMPs so we assign a 0 val 
  cgs<-rownames(DMPann[DMPann$Contrast == contrast  ,])
  mat<-ifelse(
    rownames(betas_heat) %in% rownames(DMPann[DMPann$Contrast == contrast  ,]),
    DMPann[DMPann$Contrast == contrast  , "diff_meanMeth"],
    0)
 
  heat_list = heat_list + Heatmap(
    matrix = mat, 
    name = contrast,
          #Color:
          col=col_fun,#col_fun, # Color defined in col_fun above
          na_col="white",
          
          #Legend:
          heatmap_legend_param = list(
          at = c(-1, -0.1, 0.1, 1),
          # labels = c("hypo", "", "", "hyper"),
          title = paste0(expression(beta),"diff"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
    show_heatmap_legend = ifelse(contrast == unique(DMP_ann$Contrast)[1],T,F ),
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_names_max_height = unit(2, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          heatmap_width = unit(2, "npc"),
          
              )
  
}
# Add annotation
heat_list<-heat_list + 
  Heatmap(
    matrix = DMPann[rownames(betas_heat),"Relation_to_Island"], 
    name = "Relation to island",
    #Color:
    col=setNames(palette.colors(length(unique(DMPann$Relation_to_Island)),palette = "Set1"),sort(unique(DMPann$Relation_to_Island))),#col_fun, # Color defined in col_fun above
    #Legend:
    show_heatmap_legend = TRUE,
    show_column_names = TRUE,
    column_names_side = "top",
    column_names_max_height = unit(2, "cm"),
    column_names_gp = gpar(fontsize = 9),
    column_names_rot = 90,
    heatmap_width = unit(2, "npc"),
          
              )
draw(heat_list, row_title = "some row title", row_title_gp = gpar(col = "darkblue"),
    column_title = "some column title", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)
```




This is all very nice, but I picked the less interesting comparisons, between the 2 cell lines, just because it allowed me to show the top annotation with the name inside. Imagine that you don't want to show some annotation in your plots anymore, now you must manually remove that part in 3 different places. 

To avoid thatone could easily transform the code of chunk for the plot above into a function, so you don't need to copy everything all the time.
This is specially useful if you one to change some specific detail for all your plots. Just change the function once and then just run with the new parameters:

```{r}
library(ComplexHeatmap)


meth_heatmap <- function(samplesheet, bvals, annotation   ){
  require(ComplexHeatmap)
  require(data.table)
  data.table::setDT(annotation)
  setkey(annotation,"rn")
  
  # Annotation object for top annotation:
  purity = samplesheet[,startsWith(names(samplesheet),"purity")]
  ha_column = HeatmapAnnotation(
    annotation_name_side = "left", 
    
    Type = anno_block(gp=gpar(fill= rainbow(n=unique(samplesheet$Type))),
                      labels = levels(samplesheet$Type),
                      labels_gp = gpar(col = "white", fontsize = 10)),
    Condition = samplesheet$Condition,
    purity = purity,

    col = #A list of named vectors were names = vector values and value = color.
      list(
      Condition = setNames(
        palette.colors(length(unique(samplesheet$Condition)),
                       palette = "Dark"
                       ),
        unique(samplesheet$Condition)
      ),
      purity = col_fbp(x=samplesheet,bp=seq(min(purity),max(purity),length.out=5),color="green3")
      )
  )
  
  heat_list<-ComplexHeatmap::Heatmap(
      matrix = bvals, 
            #Color:
            col=col_fn(bvals),#col_fun, # Color defined in col_fun above
            na_col="grey",
            
            #Label:
            heatmap_legend_param = list(
            at = c(0, 0.5, 1),
            # labels = c("hypo", 0, "hyper"),
            title = paste0(expression(beta),"-vals"),
            legend_height = unit(4, "cm"),
            title_position = "leftcenter-rot"
            ),
            
            
            #Rows:
            show_row_names = F,
            #row_title = "Amino acids",
            row_names_side = "left",
            #left_annotation = ha_boxplot,
            # clustering_distance_rows = "manhattan",
            
            #Columns:
            show_column_names = TRUE,
            column_names_side = "top",
            column_title_side = "bottom",
            column_names_max_height = unit(4, "cm"),
            column_names_gp = gpar(fontsize = 9),
            column_names_rot = 90,
            cluster_columns=T,
            column_split = samplesheet$Type,
            column_title = paste0(expression(beta)," values"),
  
            #Annotation bar:
            top_annotation = ha_column,
           
              
            
            #Aspect ratios:
            #column_dend_height=unit(4, "cm")
             heatmap_width = unit(2, "npc"),
            heatmap_height = unit(16, "cm"),
                )
  # Add methylation difference heatmap:  
  for (contrast in unique(annotation$Contrast))
  {
    DMPann <- annotation[ Contrast==contrast,]
    mat<-DMPann[rownames(bvals),diff_meanMeth]
    heat_list = heat_list + Heatmap(
      matrix = mat, 
      name = contrast,
            #Color:
            col=col_fun,#col_fun, # Color defined in col_fun above
            na_col="white",
            
            #Legend:
            heatmap_legend_param = list(
            at = c(-1, -0.1, 0.1, 1),
            # labels = c("hypo", "", "", "hyper"),
            title = paste0(expression(beta),"diff"),
            legend_height = unit(4, "cm"),
            title_position = "leftcenter-rot"
            ),
      show_heatmap_legend = ifelse(contrast == unique(annotation$Contrast)[1],T,F ),
            
            #Columns:
            show_column_names = TRUE,
            column_names_side = "top",
            column_names_max_height = unit(2, "cm"),
            column_names_gp = gpar(fontsize = 9),
            column_names_rot = 90,
            heatmap_width = unit(2, "npc"),
            
                )
    
  }
  # Add annotation
  ann<-annotation[,.(V1=unique(Relation_to_Island)),by=rn]
  setkey(ann,"rn")
  mat<-ann[rownames(bvals),V1]
  heat_list<-heat_list + 
    Heatmap(
      matrix = mat, 
      name = "Relation to island",
      #Color:
      col=setNames(palette.colors(length(unique(annotation$Relation_to_Island)),palette = "Set1"),sort(unique(annotation$Relation_to_Island))),#col_fun, # Color defined in col_fun above
      #Legend:
      show_heatmap_legend = TRUE,
      show_column_names = TRUE,
      column_names_side = "top",
      column_names_max_height = unit(2, "cm"),
      column_names_gp = gpar(fontsize = 9),
      column_names_rot = 90,
      heatmap_width = unit(1, "npc"),
            
                )
}

```

Now we can try this function in a new dataset, for example NBL:




### NBL top10K heatmap:


#### Load the data:

Since the dataset has been analysed independently, the normalisation could have produced differences in the values, so it is better to load the betas for the subset instead of subsetting the FULL dataset.

```{r}

ss_NBL <- readRDS("data/ss_NBL.rds") # Samplesheet same as #ss_NBL <- samplesheet[samplesheet$Type == "NBL"]
dtable(data.table::as.data.table(ss_NBL))

```

```{r}
betas_NBL <- readRDS("data/betas_NBL.rds") # Betas, have been normalised separatedly, may be different from subsetting = betas[,ss_NBL$Sample_Name]
colnames(betas) <- ss_NBL[colnames(betas),"Sample_Name"]
```

```{r}
DMPann_NBL <- readRDS("data/dmps_NBL.rds") # Totally different model and contrasts.
table(DMPann_NBL[,c("Contrast","Type")])
```

```{r}

dtable(data.table::as.data.table(DMPann_NBL))
```

#### Prepare data:

We are going to pick top10k for the demo.
```{r}
  betas_heat_NBL<-top_beta(betas_NBL,2000)

```

```{r}

ann<-data.table::as.data.table(DMPann_NBL)
setkey(ann,rn)
ann[rownames(betas_heat_NBL),list(Hyper=sum(Type=="Hyper"),Hypo=sum(Type=="Hypo")),by=Contrast]
```



#### Heatmap:

Now we have created the function, we just need to pass these 3 objects to it and done!

```{r}
heat_list_NBL<-meth_heatmap(samplesheet = ss_NBL, bvals = betas_heat_NBL, annotation = DMPann_NBL)
draw(heat_list_NBL, row_title = paste0("top ",NROW(betas_heat_NBL)," across-sample most variable sites"), row_title_gp = gpar(col = "darkblue"),
    column_title = "Methylation Heatmap", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)

 
```

```{r}
calc_ht_size = function(ht, unit = "inch") {
    pdf(NULL)
    ht = draw(ht)
    w = ComplexHeatmap:::width(ht)
    w = convertX(w, unit, valueOnly = TRUE)
    h = ComplexHeatmap:::height(ht)
    h = convertY(h, unit, valueOnly = TRUE)
    dev.off()

    c(w, h)
}
```

```{r}
size <- calc_ht_size(heat_list_NBL)
```


```{r}
pdf(paste0("NBL_heatmap", NROW(betas_heat_NBL), ".pdf"), width = size[1], height = size[2])
heat_list_NBL
dev.off()
```


When the number of rows is high the image gets compressed and we can loose some information. 
Also, sometimes we have different heatmaps with a different number of rows for each of them, which results on different aspect ratios.
If we want to control the height of each row and keep it stable between plots we must consider:
- By convention resolution in R is 96, which means 96 pixels fit on an inch. So if you don't want to loose any line your cell height should be 1 pixel tall at least. 96 lines in 1 inch means each line is 0.26mm which is already very small, so don't try to make it smaller.

- Complexheatmat default top and bottom margins are 2mm so you must add those 4mm to your plot size.
- The relationship between main heatmap object and cell height is proportional:
The height of the main plot is controlled by the height parameter the rest is annotation as explained in the docs.
So let's find the ratio for a given cell size:

```{r}
plotsizes=c(100,200)
y = NULL
for(nr in plotsizes) {
  betas<-top_beta(betas_NBL,nr)
  
    ht = draw(meth_heatmap(ss_NBL,betas,annotation = DMPann_NBL),height=unit(1/96, "inch")*nr)
    ht_height = sum(component_height(ht)) + unit(4, "mm")
    ht_height = convertHeight(ht_height, "inch", valueOnly = TRUE)
    y = c(y, ht_height)
}
sizemod <- lm(y ~ plotsizes)
sizemod
```

Now we use the formula to control for the size of the plot:

```{r}
 png(paste0("NBL_heatmap", NROW(betas_heat_NBL), ".png"),
     width =  sizemod$coefficients[2]*NROW(betas_heat_NBL + sizemod$coefficients[1]),
     height = sizemod$coefficients[2]*NROW(betas_heat_NBL) + sizemod$coefficients[1],
     units = "in",
     res = 96
     )
draw(heat_list_NBL, row_title = paste0("top ",NROW(betas_heat_NBL) ," across-sample most variable sites"), row_title_gp = gpar(col = "darkblue") , height = unit(1*1/96, "inch")*NROW(betas_heat_NBL), column_title = "Methylation Heatmap", column_title_gp = gpar(fontsize = 46),  merge_legend = TRUE)

dev.off()
    
```


It is interesting from this plot to see 

I hope you are good to go with these examples. As I mentioned before, there is a really good documentation on ComplexHeatmap library formore info. 
Now let's move on to DMRs.

## DMRplot

A good way of ploting a Differentially methylated regions DMRs is a DMRplot from the package DMRcate.


```{r}
readRDS("data/DMRs_NBL.rds")
```

