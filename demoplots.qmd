---
title: "preprocess"
author: "Izar de Villasante"
params:
  ss: "samplesheet_FULL"
  betas: "betas_FULL"
format: 
  html:
    toc: true
    toc-depth: 4
    toc-expand: 2
    # self-contained: true
    embed-resources: true
    code-fold: show
# server: shiny
execute:
  cache: true

---

```{r}
#| context: data
#| include: false
library(targets)
ss<-readRDS("data/ss_FULL.rds")
```




```{r}
# targets::tar_load(params2$ss)
# ss<-eval(rlang::sym(params2$ss))

```


## Illumina Infinium Methylation Arrays

This technical guide covers how to analyze Illumina methylation Beadchips arrays
commonly known as EPIC/450K methylation arrays.
[here some description about a methylation array and how it is prepeared...](https://emea.support.illumina.com/content/dam/illumina-support/documents/documentation/chemistry_documentation/infinium_assays/infinium_hd_methylation/infinium-hd-methylation-guide-15019519-01.pdf)

## Preprocessing

The first step once you have your data is to load it to R in an appropriate
format. The ´minfi´ packages provides read.metharray functions for this purpose.
Also the functions `read.metharray.sheet`, `read.metharray.exp` can be used.
Those are wrappers around `read.metharray` to make it easier for the user. [Check this guideline ](https://bioconductor.org/packages/devel/bioc/vignettes/minfi/inst/doc/minfi.html#3_Reading_data) or type `vignette("minfi)` on an R console for more info.
In this case a built in function `cnv.methyl::read.metharray.exp.par()` is used which is a wrapper for minfi formula with
parallelization to speed up this process a little bit.

In order to use any of this formulas we first need to generate the sample_sheet.

### Sample sheet

The sample sheet contains inforamtion about your samples and the experimental setup.
It is mandatory to respect the column names in order to make the pipline work.
 ##It must contain the following columns:
 - Sample_Name
 - Basename

 ##Other recommended columns with technical details. Can be used to track and detect batch effects:
 - Project
 - Pool_ID
 - Sample_Plate
 - Sample_Well
 - Sample_Group
 - Sentrix_ID
 - Sentrix_Position

 ##Pheno columns:
 - Gender (will be predicted)
 - Type
 - Condition
 - Any other information

In the following table, you can take a look at the sample sheet used for this project.






```{r}
#| context: server-start

library(circlize)
library(RColorBrewer)
library(DT)
library(ggplot2)
library(shiny)
library(shinyWidgets)
library(ggplot2)
library(data.table)
library(writexl)

top_beta <- function(beta_values, n=1000){
  sdv <- apply(beta_values, 1, sd)
  top100 <- names(head(sort(sdv,decreasing=T), n))
  beta_top100 <- beta_values[top100,]
  return(beta_top100)
}

```


```{r dtable}
dtable<-function(data){
  DT::datatable(
        { data},
        filter = 'top',
        # selection = list(mode = 'multiple', selected = c(1:10), target = 'column', selectable = c(-2, -3)),
        fillContainer = F,
        # style =  "bootstrap",

        extensions = 'Buttons',

        options = list(
          paging = TRUE,
          searching = TRUE,
          fixedColumns = TRUE,
          autoWidth = FALSE,
          scrollX=TRUE,
          digits=4,
          ordering = TRUE,
          dom = 'Bfrtip',
          buttons = list(
            list(
              extend = "collection",
              text = 'download entire dataset',
              action = DT::JS("function ( e, dt, node, config ) {
                                                    Shiny.setInputValue('test', true, {priority: 'event'});
                                                    }")
            ),
            'copy',
            'csv',
            'excel'
          ),

          class = "display",
          server=TRUE
        ),
      ) |> DT::formatRound(which(sapply(data,is.double)),4)
}
```

```{r}
#| context: server
myModal <- function() {

  div(id = "test",
      shiny::modalDialog(downloadButton("download1","Download data as csv"),
                         br(),
                         br(),
                         downloadButton("download2","Download data as excel"),
                         easyClose = TRUE, title = "Download Table")
  )
}

renderDT<- function(data){
  output$dtable <- DT::renderDataTable({
    dtable(data)
  })

    shiny::observeEvent(input$test, {
      print("hello")
      showModal(myModal())
    })
    output$download1 <- shiny::downloadHandler(
      filename = function() {
        paste("data-", Sys.Date(), ".csv", sep="")
      },
      content = function(file) {
        write.csv(data, file)
      }
    )

    output$download2 <- shiny::downloadHandler(
      filename = function() {
        paste("data-", Sys.Date(), ".xlsx", sep="")
      },
      content = function(file) {
        writexl::write_xlsx(data, file)
      })
}

```

```{r}

dtable(data.table::as.data.table(ss))
```

## Methylation data: The 2-channel methylation intensity file format .idat 

```{r}
ss<-data.table::as.data.table(ss)
betas<-readRDS("data/betas_FULL.rds")
colnames(betas) <- ss[colnames(betas),Sample_Name,on="barcode"]
```


## DMPs Annotation data:

A dataframe with differentially methylated probes and annotation.

```{r}
library(data.table)

DMPann<-readRDS("data/dmps_FULL.rds")

#Transform to data.table format to visualize and perform data manipulations
DMPann<-data.table::setDT(DMPann)
setkey(DMPann,"rn")
```


```{r}
# dtable(DMPann) Only if you have server backend
str(DMPann)
```


## Heatmap

When working with methylation data we would usually want to have a representative heatmap of the methylation values across the samples and see which probes are differentially methylated for each contrast.
There are many different ways to achive that, I recommend taking a look at [the wonderful docs of complexHeatmap package](https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html) for more options.

In this demonstration I will show a rather complete heatmap so you can see different useful options:

First of all let's define some functions for the color scales our heatmap will use:

```{r}
library(ComplexHeatmap)
library(circlize)
# Simple continuous palette: 
col_fun = colorRamp2(c(-1,-0.1, 0.1, 1), c("blue","white","white","red"))

# Continuous, uses a predefined color palette or manual color vector
col_fn<- function(x,n=100,palette=viridis::cividis(n)){
  colorRamp2( seq(min(x),max(x),length.out=n), palette)
}

# Continuous, monochrome breakpoints based on values distribution (quartiles):
col_fq <- function(x,probs=c(0,0.25,0.5,0.75,1),color ){
  colorRamp2( quantile(x,probs=probs), 
              monochromeR::generate_palette("white",
                blend_colour = color,  n_colours = length(probs)
                )
  )
}

# Continuous, monochrome can manually set breakpoints:
col_fbp <- function(x,bp,color){
  colorRamp2( bp, 
              monochromeR::generate_palette("white",
                blend_colour = color,  n_colours = length(bp)
                )
              )
}

```




The most relevant step is to choose an appropriate subset of representative probes/sites to show on our heatmap. 

Since we are interested on DMPs we select the probes based on the following:
For each contrast:
- DMPs must have adjusted p.value < 0.01
- DMPs must have a methylation differenece greater then 0.25
- Of those, only the top 5000 most variable probes across subjects are selected.

Feel free to modify this parameters at will.

```{r}
# Filter DMPs:
annotation<-DMPann[ abs(diff_meanMeth>0.25) & adj.P.Val < 0.01,]
setkey(annotation,Contrast)
cgs_list <- lapply(unique(DMPann$Contrast),function(x){
  idx<-annotation[x,rn]
  common <- intersect(rownames(betas),idx)
  # calculate top 5000 positions and extract the rownames
  cgs<-rownames(top_beta(betas[common,],5000))
})
# Get unique probes from the list of top methylated positions for each contrast. 
cg<-unique(unlist(cgs_list))
# Subset the beta values to contain the top (5000) cgs for each contrast
betas_heat<-betas[cg,]

```


Now we are ready to start constructing the heatmap. In fact, I will show how to create a composed heatmap from a list of heatmaps. 
The sintax for adding heatmaps is by adding heatmap objects, similar to `ggplot2`.

We will create a list of heatmaps to concatenate them vertically.
1. the main heatmap will contain the beta values and the following annotation about the different samples:
- categorical: Condition,Type.
- continuos: purity (some value I calculated about tumor purity prediction)
- annotation block: Type could be created in a similar way as Condition, but if you want to add the labels inside the box you must use anno_block. 


```{r}

samplesheet <- readRDS("data/ss_FULL.rds")
ha_column = HeatmapAnnotation(
    annotation_name_side = "left", 
    
    Type = anno_block(gp=gpar(fill= c("purple","cyan")),
                      labels = levels(samplesheet$Type),
                      labels_gp = gpar(col = "white", fontsize = 10)),
    # Type = samplesheet$Type,                  
    Condition = samplesheet$Condition,
    purity = samplesheet$purity_FULL,

    col = #A list of named vectors were names = vector values and value = color.
      list(
      # Type = c("ARMS"="purple",NBL="cyan"),
      Condition = setNames(
        palette.colors(length(unique(samplesheet$Condition)),
                       palette = "Dark"
                       ),
        unique(samplesheet$Condition)
      ),
      purity = col_fbp(x=samplesheet$purity,bp=seq(min(samplesheet$purity_FULL),max(samplesheet$purity_FULL),length.out=5),color="green3")
      )

)
```

This heatmap is divided into 2 groups ARMS and NBL with the option `column_split`, in a similar way `column_km` can be used to split based on the clustering

2. Methylation difference for each contarast. They are one column each. It could be done as a single matrix just as the first heatmap. But I wanted to illustrate how to include heatmaps with a for loop. Pay attention to the trick to hide repeated legends.

3. Some random annotation, in this case Relation to cpg island (categorical).

Remember that the rows have to be the same for all the variables. This is already happening for the beta values, but may not be for the DMPs or annotation.

```{r heatmap with annotation, fig.dim=c(22,26)}
library(ComplexHeatmap)

heat_list<-Heatmap(
    matrix = betas_heat, 
          #Color:
          col=col_fn(betas_heat),#col_fun, # Color defined in col_fun above
          na_col="grey",
          
          #Label:
          heatmap_legend_param = list(
          at = c(0, 0.5, 1),
          # labels = c("hypo", 0, "hyper"),
          title = paste0(expression(beta),"-vals"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
          
          
          #Rows:
          show_row_names = F,
          #row_title = "Amino acids",
          row_names_side = "left",
          #left_annotation = ha_boxplot,
          # clustering_distance_rows = "manhattan",
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_title_side = "bottom",
          column_names_max_height = unit(4, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          cluster_columns=T,
          column_split = samplesheet$Type,
          column_title = paste0(expression(beta)," values"),

          #Annotation bar:
          top_annotation = ha_column,
         
            
          
          #Aspect ratios:
          #column_dend_height=unit(4, "cm")
           heatmap_width = unit(2, "npc"),
          heatmap_height = unit(16, "cm"),
              )
# Add methylation difference heatmap:  
for (contrast in unique(DMPann$Contrast))
{
  # First we subset by contrast:
  DMPann_c <- DMPann[Contrast == contrast,]

  # Then we intersect with betas cgs using on = to set the key
  b <- DMPann_c[rownames(betas_heat),diff_meanMeth, on = "rn"]

  # Missing values will be assigned white color which is equivalent to 0 value/not DMP
  heat_list = heat_list + Heatmap(
    matrix = b, 
    name = contrast,
          #Color:
          col=col_fun,#col_fun, # Color defined in col_fun above
          na_col="white",
          
          #Legend:
          heatmap_legend_param = list(
          at = c(-1, -0.1, 0.1, 1),
          # labels = c("hypo", "", "", "hyper"),
          title = paste0(expression(beta),"diff"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
    show_heatmap_legend = ifelse(contrast == unique(DMPann$Contrast)[1],T,F ),
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_names_max_height = unit(2, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          heatmap_width = unit(2, "npc"),
          
              )
  
}
# Add annotation
anno<-DMPann[rownames(betas_heat),unique(Relation_to_Island),by=rn]
setkey(anno,rn)
mat<-anno[rownames(betas_heat),V1]
heat_list<-heat_list + 
  Heatmap(
    matrix = mat, 
    name = "Relation to island",
    #Color:
    col=setNames(palette.colors(length(unique(DMPann$Relation_to_Island)),palette = "Set1"),sort(unique(DMPann$Relation_to_Island))),#col_fun, # Color defined in col_fun above
    #Legend:
    show_heatmap_legend = TRUE,
    show_column_names = TRUE,
    column_names_side = "top",
    column_names_max_height = unit(2, "cm"),
    column_names_gp = gpar(fontsize = 9),
    column_names_rot = 90,
    heatmap_width = unit(2, "npc"),
          
              )
draw(heat_list, row_title = "some row title", row_title_gp = gpar(col = "darkblue"),
    column_title = "some column title", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)
```

This is quite nice visually, but it would make more sense to check for the top 10000 sites instead or maybe focus on the DMPs of a particular contrast and see how it compares to the rest. 

Let's make those 2 changes to see how we would adapt the data.

### top 10000

We only need to change the betas_heat object since the values on DMPann are based on that.

```{r}
  betas_heat<-top_beta(betas,10000)

```

Now we copy everything else from the heatmap above and repeat

```{r heatmap list 2, fig.dim=c(22,26)}
library(ComplexHeatmap)

heat_list<-Heatmap(
    matrix = betas_heat, 
          #Color:
          col=col_fn(betas_heat),#col_fun, # Color defined in col_fun above
          na_col="grey",
          
          #Label:
          heatmap_legend_param = list(
          at = c(0, 0.5, 1),
          # labels = c("hypo", 0, "hyper"),
          title = paste0(expression(beta),"-vals"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
          
          
          #Rows:
          show_row_names = F,
          #row_title = "Amino acids",
          row_names_side = "left",
          #left_annotation = ha_boxplot,
          # clustering_distance_rows = "manhattan",
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_title_side = "bottom",
          column_names_max_height = unit(4, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          cluster_columns=T,
          column_split = samplesheet$Type,
          column_title = paste0(expression(beta)," values"),

          #Annotation bar:
          top_annotation = ha_column,
         
            
          
          #Aspect ratios:
          #column_dend_height=unit(4, "cm")
           heatmap_width = unit(2, "npc"),
          heatmap_height = unit(16, "cm"),
              )
# Add methylation difference heatmap:  
for (contrast in unique(DMPann$Contrast))
{
  # First we subset by contrast:
  DMPann_c <- DMPann[Contrast == contrast,]

  # Then we intersect with betas cgs using on = to set the key
  b <- DMPann_c[rownames(betas_heat),diff_meanMeth, on = "rn"]

  # Missing values will be assigned white color which is equivalent to 0 value/not DMP
  heat_list = heat_list + Heatmap(
    matrix = b, 
    name = contrast,
          #Color:
          col=col_fun,#col_fun, # Color defined in col_fun above
          na_col="white",
          
          #Legend:
          heatmap_legend_param = list(
          at = c(-1, -0.1, 0.1, 1),
          # labels = c("hypo", "", "", "hyper"),
          title = paste0(expression(beta),"diff"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
    show_heatmap_legend = ifelse(contrast == unique(DMPann$Contrast)[1],T,F ),
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_names_max_height = unit(2, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          heatmap_width = unit(2, "npc"),
          
              )
  
}
# Add annotation
anno<-DMPann[rownames(betas_heat),unique(Relation_to_Island),by=rn]
setkey(anno,rn)
mat<-anno[rownames(betas_heat),V1]
heat_list<-heat_list + 
  Heatmap(
    matrix = mat, 
    name = "Relation to island",
    #Color:
    col=setNames(palette.colors(length(unique(DMPann$Relation_to_Island)),palette = "Set1"),sort(unique(DMPann$Relation_to_Island))),#col_fun, # Color defined in col_fun above
    #Legend:
    show_heatmap_legend = TRUE,
    show_column_names = TRUE,
    column_names_side = "top",
    column_names_max_height = unit(2, "cm"),
    column_names_gp = gpar(fontsize = 9),
    column_names_rot = 90,
    heatmap_width = unit(2, "npc"),
          
              )
draw(heat_list, row_title = "some row title", row_title_gp = gpar(col = "darkblue"),
    column_title = "some column title", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)
```
As you can see once you have the code for your plot it is pretty easy to change the input data. I will show another example with a different contrast 


### At2-Nt2:metastasi

Let's take the metastasi contrast for instance. Let's take the top 10000 DMPs for that contrast:

```{r}
  cg<-DMPann[DMPann$adj.P.Val<0.01 & abs(DMPann$diff_meanMeth)>0.25 & DMPann$Contrast=="At2-Nt2:metastasi",rn]
  betas_c <- betas[intersect(cg,rownames(betas)),]
  betas_heat<-top_beta(betas_c,10000)
```

And copy the same code for the plot again:

```{r heatmap list new contrast, fig.dim=c(22,26)}
library(ComplexHeatmap)

heat_list<-Heatmap(
    matrix = betas_heat, 
          #Color:
          col=col_fn(betas_heat),#col_fun, # Color defined in col_fun above
          na_col="grey",
          
          #Label:
          heatmap_legend_param = list(
          at = c(0, 0.5, 1),
          # labels = c("hypo", 0, "hyper"),
          title = paste0(expression(beta),"-vals"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
          
          
          #Rows:
          show_row_names = F,
          #row_title = "Amino acids",
          row_names_side = "left",
          #left_annotation = ha_boxplot,
          # clustering_distance_rows = "manhattan",
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_title_side = "bottom",
          column_names_max_height = unit(4, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          cluster_columns=T,
          column_split = samplesheet$Type,
          column_title = paste0(expression(beta)," values"),

          #Annotation bar:
          top_annotation = ha_column,
         
            
          
          #Aspect ratios:
          #column_dend_height=unit(4, "cm")
           heatmap_width = unit(2, "npc"),
          heatmap_height = unit(16, "cm"),
              )
# Add methylation difference heatmap:  
for (contrast in unique(DMPann$Contrast))
{
  # First we subset by contrast:
  DMPann_c <- DMPann[Contrast == contrast,]

  # Then we intersect with betas cgs using on = to set the key
  b <- DMPann_c[rownames(betas_heat),diff_meanMeth, on = "rn"]

  # Missing values will be assigned white color which is equivalent to 0 value/not DMP
  heat_list = heat_list + Heatmap(
    matrix = b, 
    name = contrast,
          #Color:
          col=col_fun,#col_fun, # Color defined in col_fun above
          na_col="white",
          
          #Legend:
          heatmap_legend_param = list(
          at = c(-1, -0.1, 0.1, 1),
          # labels = c("hypo", "", "", "hyper"),
          title = paste0(expression(beta),"diff"),
          legend_height = unit(4, "cm"),
          title_position = "leftcenter-rot"
          ),
    show_heatmap_legend = ifelse(contrast == unique(DMPann$Contrast)[1],T,F ),
          
          #Columns:
          show_column_names = TRUE,
          column_names_side = "top",
          column_names_max_height = unit(2, "cm"),
          column_names_gp = gpar(fontsize = 9),
          column_names_rot = 90,
          heatmap_width = unit(2, "npc"),
          
              )
  
}
# Add annotation
anno<-DMPann[rownames(betas_heat),unique(Relation_to_Island),by=rn]
setkey(anno,rn)
mat<-anno[rownames(betas_heat),V1]
heat_list<-heat_list + 
  Heatmap(
    matrix = mat, 
    name = "Relation to island",
    #Color:
    col=setNames(palette.colors(length(unique(DMPann$Relation_to_Island)),palette = "Set1"),sort(unique(DMPann$Relation_to_Island))),#col_fun, # Color defined in col_fun above
    #Legend:
    show_heatmap_legend = TRUE,
    show_column_names = TRUE,
    column_names_side = "top",
    column_names_max_height = unit(2, "cm"),
    column_names_gp = gpar(fontsize = 9),
    column_names_rot = 90,
    heatmap_width = unit(2, "npc"),
          
              )
draw(heat_list, row_title = "some row title", row_title_gp = gpar(col = "darkblue"),
    column_title = "some column title", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)
```




This is all very nice, but I picked the less interesting comparisons, between the 2 cell lines, just because it allowed me to show the top annotation with the name inside. Imagine that you don't want to show some annotation in your plots anymore, or change any other detail of your plots. Now you must manually remove that part in 3 different places. 

To avoid that, one could easily transform the code of chunk for the plot above into a function, so you don't need to copy everything all the time.
This is specially useful if you one to change some specific detail for all your plots. Just change the function once and then just run with the new parameters:

```{r heatmap function}
library(ComplexHeatmap)


meth_heatmap <- function(samplesheet, bvals, annotation   ){
  require(ComplexHeatmap)
  require(data.table)
  data.table::setDT(annotation)
  setkey(annotation,"rn")
  
  # Annotation object for top annotation:
  purity = samplesheet[,startsWith(names(samplesheet),"purity")]
  ha_column = HeatmapAnnotation(
    annotation_name_side = "left", 
    
    Type = anno_block(gp=gpar(fill= rainbow(n=unique(samplesheet$Type))),
                      labels = levels(samplesheet$Type),
                      labels_gp = gpar(col = "white", fontsize = 10)),
    Condition = samplesheet$Condition,
    purity = purity,

    col = #A list of named vectors were names = vector values and value = color.
      list(
      Condition = setNames(
        palette.colors(length(unique(samplesheet$Condition)),
                       palette = "Dark"
                       ),
        unique(samplesheet$Condition)
      ),
      purity = col_fbp(x=samplesheet,bp=seq(min(purity),max(purity),length.out=5),color="green3")
      )
  )
  
  heat_list<-ComplexHeatmap::Heatmap(
      matrix = bvals, 
            #Color:
            col=col_fn(bvals),#col_fun, # Color defined in col_fun above
            na_col="grey",
            
            #Label:
            heatmap_legend_param = list(
            at = c(0, 0.5, 1),
            # labels = c("hypo", 0, "hyper"),
            title = paste0(expression(beta),"-vals"),
            legend_height = unit(4, "cm"),
            title_position = "leftcenter-rot"
            ),
            
            
            #Rows:
            show_row_names = F,
            #row_title = "Amino acids",
            row_names_side = "left",
            #left_annotation = ha_boxplot,
            # clustering_distance_rows = "manhattan",
            
            #Columns:
            show_column_names = TRUE,
            column_names_side = "top",
            column_title_side = "bottom",
            column_names_max_height = unit(4, "cm"),
            column_names_gp = gpar(fontsize = 9),
            column_names_rot = 90,
            cluster_columns=T,
            column_split = samplesheet$Type,
            column_title = paste0(expression(beta)," values"),
  
            #Annotation bar:
            top_annotation = ha_column,
           
              
            
            #Aspect ratios:
            #column_dend_height=unit(4, "cm")
             heatmap_width = unit(2, "npc"),
            heatmap_height = unit(16, "cm"),
                )
  # Add methylation difference heatmap:  
  for (contrast in unique(annotation$Contrast))
  {
    DMPann <- annotation[ Contrast==contrast,]
    mat<-DMPann[rownames(bvals),diff_meanMeth]
    heat_list = heat_list + Heatmap(
      matrix = mat, 
      name = contrast,
            #Color:
            col=col_fun,#col_fun, # Color defined in col_fun above
            na_col="white",
            
            #Legend:
            heatmap_legend_param = list(
            at = c(-1, -0.1, 0.1, 1),
            # labels = c("hypo", "", "", "hyper"),
            title = paste0(expression(beta),"diff"),
            legend_height = unit(4, "cm"),
            title_position = "leftcenter-rot"
            ),
      show_heatmap_legend = ifelse(contrast == unique(annotation$Contrast)[1],T,F ),
            
            #Columns:
            show_column_names = TRUE,
            column_names_side = "top",
            column_names_max_height = unit(2, "cm"),
            column_names_gp = gpar(fontsize = 9),
            column_names_rot = 90,
            heatmap_width = unit(2, "npc"),
            
                )
    
  }
  # Add annotation
  ann<-annotation[,.(V1=unique(Relation_to_Island)),by=rn]
  setkey(ann,"rn")
  mat<-ann[rownames(bvals),V1]
  heat_list<-heat_list + 
    Heatmap(
      matrix = mat, 
      name = "Relation to island",
      #Color:
      col=setNames(palette.colors(length(unique(annotation$Relation_to_Island)),palette = "Set1"),sort(unique(annotation$Relation_to_Island))),#col_fun, # Color defined in col_fun above
      #Legend:
      show_heatmap_legend = TRUE,
      show_column_names = TRUE,
      column_names_side = "top",
      column_names_max_height = unit(2, "cm"),
      column_names_gp = gpar(fontsize = 9),
      column_names_rot = 90,
      heatmap_width = unit(1, "npc"),
            
                )
}

```

Now we can try this function in a new dataset, for example NBL:




### NBL top10K heatmap:


#### Load the data:

Since the dataset has been analysed independently, the normalisation could have produced differences in the values, so it is better to load the betas for the subset instead of subsetting the FULL dataset.

```{r}
library(data.table)
ss_NBL <- readRDS("data/ss_NBL.rds") # Samplesheet same as #ss_NBL <- samplesheet[samplesheet$Type == "NBL"]
ss_NBL<-data.table::as.data.table(ss_NBL)
dtable(ss_NBL)

```

```{r}
betas_NBL <- readRDS("data/betas_NBL.rds") # Betas, have been normalised separatedly, may be different from subsetting = betas[,ss_NBL$Sample_Name]
colnames(betas_NBL) <- ss_NBL[colnames(betas_NBL),Sample_Name,on="barcode"]
```

```{r}
DMPann_NBL <- readRDS("data/dmps_NBL.rds") # Totally different model and contrasts.
table(DMPann_NBL[,c("Contrast","Type")])
```

```{r}

# dtable(data.table::as.data.table(DMPann_NBL))
head(DMPann_NBL)
```

#### Prepare data:

We are going to pick top10k for the demo.
```{r}
  betas_heat_NBL<-top_beta(betas_NBL,2000)

```

```{r}
library(data.table)
ann<-data.table::as.data.table(DMPann_NBL)
setkey(ann,rn)
ann[rownames(betas_heat_NBL),list(Hyper=sum(Type=="Hyper"),Hypo=sum(Type=="Hypo")),by=Contrast]
```



#### Heatmap:

Now we have created the function, we just need to pass these 3 objects to it and done!

```{r}
heat_list_NBL<-meth_heatmap(samplesheet = ss_NBL, bvals = betas_heat_NBL, annotation = DMPann_NBL)
draw(heat_list_NBL, row_title = paste0("top ",NROW(betas_heat_NBL)," across-sample most variable sites"), row_title_gp = gpar(col = "darkblue"),
    column_title = "Methylation Heatmap", column_title_gp = gpar(fontsize = 16),  merge_legend = TRUE)

 
```

##### Plot size:

There are many things you can do in order to change the plot size and aesthetics. I won't go in detail but I think that getting the right plot size can be a bit tricky. So here is some advice on how to get it right.
Here is a function to get the width and hight of your plot.

```{r}
calc_ht_size = function(ht, unit = "inch") {
    pdf(NULL)
    ht = draw(ht)
    w = ComplexHeatmap:::width(ht)
    w = convertX(w, unit, valueOnly = TRUE)
    h = ComplexHeatmap:::height(ht)
    h = convertY(h, unit, valueOnly = TRUE)
    dev.off()

    c(w, h)
}
```

```{r}
size <- calc_ht_size(heat_list_NBL)
```


```{r}
pdf(paste0("NBL_heatmap", NROW(betas_heat_NBL), ".pdf"), width = size[1], height = size[2])
heat_list_NBL
dev.off()
```


When the number of rows is high the image gets compressed and we can loose some information. 
Also, sometimes we have different heatmaps with a different number of rows for each of them, which results on different aspect ratios.
If we want to control the height of each row and keep it stable between plots we must consider:
- By convention resolution in R is 96, which means 96 pixels fit on an inch. So if you don't want to loose any line your cell height should be 1 pixel tall at least. 96 lines in 1 inch means each line is 0.26mm which is already very small, so don't try to make it smaller.

- Complexheatmat default top and bottom margins are 2mm so you must add those 4mm to your plot size.
- The relationship between main heatmap object and cell height is proportional:
The height of the main plot is controlled by the height parameter the rest is annotation as explained in the docs.
So let's find the ratio for a given cell size:

```{r}
plotsizes=c(100,200)
y = NULL
for(nr in plotsizes) {
  betas<-top_beta(betas_NBL,nr)
  
    ht = draw(meth_heatmap(ss_NBL,betas,annotation = DMPann_NBL),height=unit(1/96, "inch")*nr)
    ht_height = sum(component_height(ht)) + unit(4, "mm")
    ht_height = convertHeight(ht_height, "inch", valueOnly = TRUE)
    y = c(y, ht_height)
}
sizemod <- lm(y ~ plotsizes)
sizemod
```

Now we use the formula to control for the size of the plot:

```{r}
 png(paste0("NBL_heatmap", NROW(betas_heat_NBL), ".png"),
     width =  sizemod$coefficients[2]*NROW(betas_heat_NBL + sizemod$coefficients[1]),
     height = sizemod$coefficients[2]*NROW(betas_heat_NBL) + sizemod$coefficients[1],
     units = "in",
     res = 96
     )
draw(heat_list_NBL, row_title = paste0("top ",NROW(betas_heat_NBL) ," across-sample most variable sites"), row_title_gp = gpar(col = "darkblue") , height = unit(1*1/96, "inch")*NROW(betas_heat_NBL), column_title = "Methylation Heatmap", column_title_gp = gpar(fontsize = 46),  merge_legend = TRUE)

dev.off()
    
```


It is interesting from this plot to see 

I hope you are good to go with these examples. As I mentioned before, there is a really good documentation on ComplexHeatmap library formore info. 
Now let's move on to DMRs.

## DMRplot

A good way of ploting a Differentially methylated regions DMRs is a DMRplot from the package DMRcate.

First we load the DMRs object claculated with dmrcate:
```{r}
DMRs <- readRDS("data/DMRs_NBL.rds")
```

Now we choose which region to look at. Say the most significant DMR based on HMFDR score

```{r}
library(data.table)
data.table::setorder(DMRs,HMFDR)
dmr1<-DMRs[1,]

```

We need the following info in order to make the plot:
- genome: reference genome = "hg19", for our case
- chr: chromosome to plot 
- start: position in chromosome to start
- end: position end
- CpGs: GenomicRanges object with cpg site. 
- DMRs: DMRs
- enhancers 
- feature

Now let's look for those things:
```{r}
# reference genome of the specie to plot
genome <- "hg19"
```
We have the cpgs annotated on DMPann_NBL object above. NOw let's make this into a GRanges object:
```{r}
library(GenomicRanges)
# GenomicRanges object including the position of the CpG site and its beta values associated

DMPann_NBL$start <- DMPann_NBL$pos
DMPann_NBL$end <- DMPann_NBL$pos
CpGs<-GenomicRanges::GRanges(DMPann_NBL,strand = "*")

```

Great! what about only the Cpgs for our DMR

```{r subset DMPann}
# chromosome to represent
chr <- dmr1$seqnames
# range to plot (first and last position) we look +-500bp of the DMR in this case
start <- dmr1$start - 500
end <- dmr1$end + 500

q <- GenomicRanges::GRanges(seqnames=chr,
                            ranges=IRanges(start = start, end = end),
                            strand="*")
cpgIslands <- subsetByOverlaps(CpGs,q)
```
Now we can already visualize that as a track:
```{r}
library(Gviz)
#Annotation track, title ="CpG"
atrack <- AnnotationTrack(cpgIslands, name = "CpG")
plotTracks(atrack)
```

### DMR

We can also plot the dmr object:
```{r}
library(Gviz)
library(GenomicRanges)
#Annotation track, title ="DMR"

DMR_track <- AnnotationTrack(dmr1,genome = "hg19", chromosome=as.character(chr), name="DMRs", col="purple4", fill="purple4")
plotTracks(DMR_track)
```
So we don'really see where do those fall in the genome we need coordinates!

```{r}
gtrack <- GenomeAxisTrack(q@ranges)
plotTracks(gtrack)
```
Let's put all 3 together:

```{r }
## genomic coordinates
plotTracks(list(gtrack,DMR_track,atrack))

```
Wouldn't it be nice to have an idea of where in the chromosome we are looking at?

```{r}
# reference genome of the specie to plot
genome <- "hg19"
# chromosome to represent
chr <- dmr1$seqnames
#Ideogram track
itrack <- IdeogramTrack(genome = genome, chromosome = chr)
plotTracks(list(itrack, gtrack, atrack,DMR_track))
```
But we want to see now some left and right flanking positions:

```{r}
plotTracks(list(itrack, gtrack, atrack,DMR_track), 
             extend.left=0.1, extend.right=0.1)
```
### Gene

We can utilize gene model information from an existing local source. Alternatively, we could download such data from one of the available online resources like UCSC or ENSEBML, and there are constructor functions to handle these tasks.

```{r}
library(org.Hs.eg.db)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)

# gene model
  txdb_hg19 <- TxDb.Hsapiens.UCSC.hg19.knownGene # human model
  gene_model <- GeneRegionTrack(txdb_hg19, genome=genome, chromosome=chr, showId=TRUE, geneSymbol=TRUE, name="UCSC")
  ## show symbol ID instead of transcript ID
  symbols <- unlist(mapIds(org.Hs.eg.db, gene(gene_model), "SYMBOL", "ENTREZID", multiVals="first"))
  ### *mouse*: symbols <- unlist(mapIds(org.Mm.eg.db, gene(gene_model), "SYMBOL", "ENTREZID", multiVals="first"))
  symbol(gene_model) <- symbols[gene(gene_model)]
  plotTracks(list(itrack, gtrack, gene_model,atrack,DMR_track),from=start, to=end, 
             extend.left=0.1, extend.right=0.1)
```


Now we would like to see some more information about how much methylated are the CpGs:

```{r gviz scatter}
# Get probes that 
names(cpgIslands)<-cpgIslands$rn
probeIDS<-intersect(cpgIslands$rn,rownames(betas_NBL))
probeIDS

cpgs <- cpgIslands[probeIDS,]
cpgs
values(cpgs)<-betas_NBL[probeIDS,]
# Which variable you want to group by:
grp <- as.character(ss_NBL$Condition)

dtrack <- DataTrack(cpgs, genome = genome, name="B-vals", chromosome=chr, type=c("a","p"), groups=grp)

plotTracks(dtrack,from=start+450, to=end-450)

```

Now let's add this new feature to our plot:

```{r gviz combo}
  plotTracks(list(itrack, gtrack, gene_model,dtrack,DMR_track),from=start+500, to=end-500,
             extend.left=0.1, extend.right=0.1)
```

We can also visualize DMPs as heatmap which is interesting where there are many values for example:

```{r gviz combo and heatmap}
# heatmap of the methylation values at every CpG site
  heatmap <- DataTrack(cpgs, name=" heat",chromosome = chr, type="heatmap", showSampleNames=T, cex.sampleNames=0.7,
                      gradient=c(colorRampPalette(c("blue", "white", "red"))(n = 299)), separator=2)
  plotTracks(list(itrack, gtrack, gene_model,dtrack,DMR_track,heatmap),from=start+500, to=end-500,
             extend.left=0.1, extend.right=0.1)

```


And you could add any annotation as long it is in a IRanges object. So take a look at GenomicRanges and gviz package vignettes. I would recommend this [demo](http://www.sthda.com/english/wiki/gviz-visualize-genomic-data)